思路：通过观察，先减再乘运算少，但我们不知道要减多少，
     所以反向思考，从Y如何得到X。当Y比X小的时候，只能通过X不断减1得到Y，直接返回X-Y；当Y比X大的时候，分奇偶讨论。Y是偶数，
     则Y只能通过某个数乘2后大于等于Y，然后减0或者2k得到，发现(Y+2) / 2 vs Y/2 + 1，后者运算次数少，所以无论哪种情况，都可以先除2。
     当Y是奇数的时候，Y可以加2k+1个1再除2，但是因为对于2k来说，先除在+1比先加再除运算少，所以我们要先加1变成偶数，然后除，之后看情况是否继续加1。

时间复杂度: O(log(Y)) 每次减少的不是Y-X的一半，而是Y的一半
空间复杂度: O(1)

class Solution {
    public int brokenCalc(int X, int Y) {
        if (Y < X) {
            return X - Y;
        }
        
        int res = 0;
        while (X < Y) {
            if (Y % 2 == 1) {
                Y += 1;
                res++;
            } else {
                Y /= 2;
                res++;
            }
        }
        
        return res + X - Y;
    }
}
