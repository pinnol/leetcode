思路：设原序列是A，目标序列是B
那么容易知道，B中的元素一定是A中元素的子集。

将A中元素排序得到C
f[i][j]表示 将前i个变成非减，最后元素不大于c[j]的最少操作

转移方程：
f[i][j]=min(f[i][j−1],f[i−1][j]+abs(a[i-1]−c[j-1]))，
前者是改变后小于等于C[j - 1]的情况，后者是改变前A[i - 1]大于C[j - 1]，然后改成等于的情况。

举例【4，3，5】
dp[2][2] = 1 是(4，4)
dp[3][1] = 3 是(3, 3, 3)
dp[3][2] = 2 是(4, 4, 4) *

* 因为4, 4只需要再将5变成4就可以实现新串，而从dp[2][2]变到这里只需1 + 1，从dp[3][2]虽然不需要变，却需要3的花费。

最终结果是【4，4，5】

时间复杂度：O(n^2)
空间复杂度：O(n^2)




