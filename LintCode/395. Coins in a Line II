// 九章的方法是以0为基准，从最后倒推到第一个的情况，看是否大于等于0，如果我们不把最后设置为0，而是n，那么就要比较是否大于等于n
public class Solution {
    /**
     * @param values: a vector of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] A) {
        int n = A.length;
        int[] f = new int[n + 1];
        f[n] = 0;
        int i;
        for (i = n - 1; i >= 0; --i){
            f[i] = A[i] - f[i + 1];
            if (i < n - 1) {
                f[i] = Math.max(f[i], A[i] + A[i + 1] - f[i + 2]);
            }
        }
        
        return f[0] >= 0;
    }
}


public class Solution {
    /**
     * @param values: a vector of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] values) {
        if (values == null || values.length < 3) {
            return true;
        }
        
        int n = values.length;
        
        int[] f = new int[n + 1];
        f[1] = values[n - 1];
        
        for (int i = 2; i <= n; i++) {
            f[i] = Math.max(-f[i - 1] + values[n - i], -f[i - 2] + values[n - i] + values[n - i + 1]);
        }
        
        return f[n] >= 0;
    }
}
