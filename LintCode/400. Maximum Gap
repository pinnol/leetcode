思路：借鉴了bucket sort的思想，取gloabal max and min，
令桶的大小为最大间隔的平均数，即（max - min）/ num，每个桶之内的数字之间的距离一定小于平均值，
所以一定不可能是答案，只要每个相邻桶的最小值与前一个桶的最大值之间的差有可能成为答案（因为要相邻）。
本题的一个难点在于定义桶的大小。
本题与bucket sort的区别在于没有桶内排序的过程，也没有合并所有桶结果的过程。

bucket的数量应该为nums.length，bucket[nums.length - 1]中只有最大值max。
使用long规避integer MAX_VALUE的情况。

time complexity: O(n)
space complexity: O(n)


public class Solution {
    /**
     * @param nums: an array of integers
     * @return: the maximun difference
     */
    public int maximumGap(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }
        
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        
        for (int num : nums) {
            min = Math.min(num, min);
            max = Math.max(num, max);
        }
        // System.out.println("min="+min);
        double size = (double) (max - min) / (nums.length - 1);
        // System.out.println("size="+size);
        long[] bucketMin = new long[nums.length];
        long[] bucketMax = new long[nums.length];
        
        for (int i = 0; i < nums.length; i++) {
            bucketMax[i] = Long.MIN_VALUE;
            bucketMin[i] = Long.MAX_VALUE;
        }
        
        for (int i = 0; i < nums.length; i++) {
            int pos = (int) Math.floor((nums[i] - min) / size);
            // System.out.println("pos="+pos);
            // System.out.println("num="+nums[i]);

            
            bucketMax[pos] = Math.max(nums[i], bucketMax[pos]);
            bucketMin[pos] = Math.min(nums[i], bucketMin[pos]);
            // if (pos == 3) {
            //     System.out.println("pos = "+3);            
            //     System.out.println("bucketMin = " + bucketMin[pos]);
            // }
        }
        
        
        // for (int i = 0; i < nums.length; i++) {
        //     System.out.println("i = "+i);
        //     System.out.println("bucketMin = "+bucketMin[i]);
        //     System.out.println("bucketMax = "+ bucketMax[i]);
        // }
        
        
        long res = 0;
        int pre = 0;
        for (int i = 1; i < nums.length; i++) {
            if (bucketMin[i] == Long.MAX_VALUE) {
                continue;
            }
            // System.out.println("i="+i);
            // System.out.println("bucketMin[i]="+bucketMin[i]);
            // System.out.println("pre="+pre);
            // System.out.println("bucketMax="+ bucketMax[pre]);
            res = Math.max(res, bucketMin[i] - bucketMax[pre]);
            pre = i;

        }
        return (int) res;
    }
}
